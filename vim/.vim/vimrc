" Greg Anders (gpanders)'s vimrc <https://github.com/gpanders/dotfiles.git>

" Detect OS {{{
if !exists('g:os')
  if has('win64') || has('win32') || has('win16')
    let g:os = "Windows"
  else
    let g:os = substitute(system('uname'), '\n', '', '')
  endif
endif
" }}}

" Set $MYVIMRUNTIME
if g:os ==# 'Windows'
  let $MYVIMRUNTIME = $HOME . '/vimfiles'
else
  let $MYVIMRUNTIME = $HOME . '/.vim'
endif

" Use vim-pathogen if native packages are not supported {{{
if !has('packages')
  " Use vim-pathogen to emulate native packaging behavior
  if empty(glob($MYVIMRUNTIME . '/autoload/pathogen.vim'))
    silent execute '!curl -LSso ' . $MYVIMRUNTIME . '/autoload/pathogen.vim https://tpo.pe/pathogen.vim'
  endif
  silent! execute pathogen#infect('pack/{}/start/{}', 'pack/{}/opt/{}')
endif
" }}}

if has('autocmd')
  filetype plugin indent on
endif

if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif

" Set color scheme {{{

if has('termguicolors')
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors
else
  let g:onedark_termcolors = 16
endif

" Solarized {{{
" ---------
" if &bg ==# 'light'
"   silent! colorscheme flattened_light
" else
"   silent! colorscheme flattened_dark
" endif
" }}}
" One Dark {{{
" --------
silent! packadd! onedark.vim
silent! colorscheme onedark
" }}}

" If no other colorscheme, use vim default
if !exists('g:colors_name')
  set bg=dark
endif

" Try to make comments italic
highlight Comment gui=italic cterm=italic

" Highlight trailing whitespace
highlight TrailingWhitespace ctermbg=204 guibg=#E06C75

" }}}

" GUI settings {{{
if has('gui_running')
  if g:os ==# 'Windows'
    set guifont=Fira_Mono:h10:cANSI:qDRAFT
  elseif g:os ==# 'Darwin'
    set guifont=FiraMono-Regular:h11
  endif
  set guioptions=teMg!
  set lines=60
  set columns=180
endif
" }}}

" Set curor shape based on mode
if !has('nvim')
  " Vertical bar in insert mode
  let &t_SI = "\e[6 q"
  " Underline in replace mode
  let &t_SR = "\e[4 q"
  " Block in normal mode
  let &t_EI = "\e[2 q"
endif

" Use UTF-8 if we can and env LANG didn't tell us not to
if has('multi_byte') && !exists('$LANG') && &encoding ==# 'latin1'
  set encoding=utf-8
endif

" Sudo save
cnoreabbrev w!! w !sudo tee > /dev/null %

" Type ~ when using :edit to jump back to the home directory
" e.g:
"   :e /some/long/path/~ => :e ~/
function! <SID>JumpToHome()
  let cmdline = getcmdline()
  if cmdline[0:1] ==# 'e ' || cmdline[0:1] ==# 'ed'
    return "\<C-\>e'e ~/'\<CR>"
  else
    return '~/'
  endif
endfunction
cnoremap <expr> ~/ <SID>JumpToHome()

" Settings {{{
" Press K to open help docs for option under the cursor
set smarttab
set softtabstop=4
set shiftwidth=4
set autoindent
set expandtab
set number
set hidden
set ignorecase
set smartcase
set magic
set incsearch
set hlsearch
set cursorline
set splitbelow
set splitright
set nostartofline
set scrolloff=2
set sidescrolloff=5
set showmatch
set matchtime=2
set matchpairs+=<:>
set foldmarker=\ {{{,\ }}}
set modeline
set virtualedit+=block
set lazyredraw
set linebreak
set include=
set nrformats-=octal
set display+=lastline
set autoread
set confirm
set pumheight=10
set noshowmode
set nolangremap

" Color the whole area outside of 'textwidth'
let &colorcolumn = '+' . join(range(1, 256), ',+')

" Indent wrapped lines
silent! set breakindent

" Add more completion options
set completeopt=menuone,longest,preview

if !has('nvim') && &ttimeoutlen == -1
  set ttimeout
  set ttimeoutlen=100
endif

" Allow backspacing over all whitespace
set backspace=indent,eol,start

" Specify whitespace chars
set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+

" Delete comment characters when joining commented lines
set formatoptions+=j

if has('path_extra')
  setglobal tags-=./tags tags-=./tags; tags^=./tags;
endif

" Increase Vim's command history
set history=1000

" Set max number of tab pages
set tabpagemax=50

" Keep and store UPPERCASE global variables
if !empty(&viminfo)
  set viminfo^=!
endif

" Don't save options in session files
set sessionoptions-=options

set path-=/usr/include     " Let C/C++ filetypes set this
set path+=**               " Search current directory's whole tree

set ruler
set wildmenu
set wildcharm=<C-Z>
set wildmode=full
set wildignorecase
set wildignore+=*/.git/**/*,*/.hg/**/*,*/.svn/**/*
set wildignore+=tags
" }}}

" Statusline {{{
" Set the statusline
function! StatuslineLineEnding()
  if &ff ==# 'unix'
    return 'LF'
  elseif &ff ==# 'dos'
    return 'CRLF'
  elseif &ff ==# 'mac'
    return 'CR'
  endif
endfunction

function! StatuslineGitBranch()
  if exists('*FugitiveHead')
    let branch = FugitiveHead()
    if branch != ""
      return "  î‚  " . branch . " "
    endif
  endif
  return ""
endfunction

function! StatuslineMode()
  let m = mode()
  if m ==# 'n'
    highlight! link StatuslineMode StatuslineModeNormal
    return 'N'
  elseif m ==# 'i'
    highlight! link StatuslineMode StatuslineModeInsert
    return 'I'
  elseif m ==# 'R'
    highlight! link StatuslineMode StatuslineModeReplace
    return 'R'
  elseif m ==? 'v' || m==# ''
    highlight! link StatuslineMode StatuslineModeVisual
    return 'V'
  else
    highlight! link StatuslineMode StatuslineModeNormal
    return toupper(m)
  endif
endfunction

function! StatuslineFlags()
  let str = ''
  if &mod
    let str .= '+ '
  endif
  if &ro
    let str .= '[RO] '
  endif
  return str
endfunction

set laststatus=2
set statusline=                               " Reset the statusline
set statusline+=%#StatuslineMode#
set statusline+=\ %{StatuslineMode()}\        " Mode indicator
set statusline+=%*
set statusline+=%1*\ %<%f\                    " Filename
set statusline+=%{StatuslineFlags()}          " Help/modified/RO markers
set statusline+=%2*\ %n\                      " Buffer number
set statusline+=%3*                           " Reset color
set statusline+=%{StatuslineGitBranch()}      " Git branch (with icon)
set statusline+=%=                            " Break point for right justify

set statusline+=%{&ft}\                       " Filetype
set statusline+=%{StatuslineLineEnding()}\    " Line ending type
set statusline+=%4*\ %(%l:%c%V%)\             " Line and column number
set statusline+=%5*\ %P\                      " Percent through file

" Set User1-9 highlight groups for statusline
" These are used by adding %N* to the statusline, where {N} is 1-9
" The following uses the solarized color scheme
if exists('g:colors_name')
  if g:colors_name ==# 'solarized8'
    if &background ==# 'light'
      hi User1 ctermfg=15 ctermbg=11 guifg=#FDF6E3 guibg=#657B83
      hi User2 ctermfg=15 ctermbg=14 guifg=#FDF6E3 guibg=#93A1A1
      hi User3 ctermfg=11 ctermbg=7 guifg=#657B83 guibg=#EEE8D5
      hi User4 ctermfg=15 ctermbg=14 guifg=#FDF6E3 guibg=#93A1A1
      hi User5 ctermfg=15 ctermbg=11 guifg=#FDF6E3 guibg=#657B83

      " Colors for statusline mode indicator
      hi StatuslineModeNormal ctermfg=145 ctermbg=236 guifg=#ABB2BF guibg=#2C323C
      hi StatuslineModeInsert ctermfg=235 ctermbg=39 guifg=#282C34 guibg=#61AFEF
      hi StatuslineModeReplace ctermfg=235 ctermbg=204 guifg=#282C34 guibg=#E06C75
      hi StatuslineModeVisual ctermfg=235 ctermbg=170 guifg=#282C34 guibg=#C678DD
    else
      hi User1 ctermfg=8 ctermbg=12 guifg=#002B36 guibg=#839496
      hi User2 ctermfg=8 ctermbg=10 guifg=#002B36 guibg=#586E75
      hi User3 ctermfg=12 ctermbg=0 guifg=#839496 guibg=#073642
      hi User4 ctermfg=8 ctermbg=10 guifg=#002B36 guibg=#586E75
      hi User5 ctermfg=8 ctermbg=12 guifg=#002B36 guibg=#839496

      " Colors for statusline mode indicator
      hi StatuslineModeNormal ctermfg=145 ctermbg=236 guifg=#ABB2BF guibg=#2C323C
      hi StatuslineModeInsert ctermfg=235 ctermbg=39 guifg=#282C34 guibg=#61AFEF
      hi StatuslineModeReplace ctermfg=235 ctermbg=204 guifg=#282C34 guibg=#E06C75
      hi StatuslineModeVisual ctermfg=235 ctermbg=170 guifg=#282C34 guibg=#C678DD
    endif
  elseif g:colors_name ==# 'onedark'
    hi User1 cterm=reverse gui=reverse
    hi User2 ctermbg=237 guibg=#3E4452
    hi User3 ctermfg=145 ctermbg=235 guifg=#ABB2BF guibg=#282C34
    hi User4 ctermbg=237 guibg=#3E4452
    hi User5 cterm=reverse gui=reverse

    " Colors for statusline mode indicator
    hi StatuslineModeNormal ctermfg=145 ctermbg=236 guifg=#ABB2BF guibg=#2C323C
    hi StatuslineModeInsert ctermfg=235 ctermbg=39 guifg=#61AFEF guibg=#282C34
    hi StatuslineModeReplace ctermfg=235 ctermbg=204 guifg=#E06C75 guibg=#282C34
    hi StatuslineModeVisual ctermfg=235 ctermbg=170 guifg=#C678DD guibg=#282C34
  endif
endif
" }}}

" Set a single backup directory
set backup
if g:os ==# 'Windows'
  set backupdir^=~/vimfiles/cache/backup
else
  set backupdir^=~/.vim/cache/backup
endif

" Enable persistent undo
if has('persistent_undo')
  set undofile
  if g:os ==# 'Windows'
    set undodir^=~/vimfiles/cache/undo
  else
    set undodir^=~/.vim/cache/undo
  endif
endif

" Keep swap files in one place
if g:os ==# 'Windows'
  set directory^=~/vimfiles/cache/swap//
else
  set directory^=~/.vim/cache/swap//
endif

" Set dictionary if it exists
if g:os !=# 'Windows' && filereadable('/usr/share/dict/words')
  set dictionary+=/usr/share/dict/words
endif

" Insert mode mappings {{{

" jk in Insert mode escapes to Normal mode
inoremap jk <Esc>l

" Set a new 'undo point' before undoing entire line
inoremap <C-U> <C-G>u<C-U>

" Auto close braces in insert mode
inoremap {<CR> {<CR>}<Esc>ko

" Make insert completion easier
inoremap <silent> ,f <C-X><C-F>
inoremap <silent> ,l <C-X><C-L>
inoremap <silent> ,d <C-X><C-D>
inoremap <silent> ,o <C-X><C-O>
inoremap <silent> ,i <C-X><C-I>
inoremap <silent> ,n <C-X><C-N>
inoremap <silent> ,t <C-X><C-]>
inoremap <silent> ,u <C-X><C-U>

" }}}

" Normal mode mappings {{{

" Save by pressing <leader>w
nnoremap <silent> ,w :w<CR>

" Navigate through wrapped lines individually
nnoremap <silent> j gj
nnoremap <silent> k gk

" Map Q to gq
noremap Q gq

" Buffer shortcuts
nnoremap <silent> ,1 :b1<CR>
nnoremap <silent> ,2 :b2<CR>
nnoremap <silent> ,3 :b3<CR>
nnoremap <silent> ,4 :b4<CR>
nnoremap <silent> ,5 :b5<CR>
nnoremap <silent> ,6 :b6<CR>
nnoremap <silent> ,7 :b7<CR>
nnoremap <silent> ,8 :b8<CR>
nnoremap <silent> ,9 :b9<CR>
nnoremap <silent> ,0 :b10<CR>

" List buffers and put :b on the command line
noremap ,b :buffers<CR>:b<Space>

" Remap & to preserve substitution flags
nnoremap <silent> & :&&<CR>

" Backspace goes back to previous buffer
nnoremap <silent> <Space><Tab> <C-^>

" Map ,, to ,
nnoremap ,, ,

" ,f prefixes find files in path
nnoremap ,f :find *
nnoremap ,vf :vert sf *
nnoremap ,sf :sf *

" Search for a tag by regex
nnoremap ,t :tjump /
nnoremap ,p :ptjump /

" Find files in current buffer's directory
nnoremap ,e :e <C-R>=expand('%:p:h') . '/'<CR>
nnoremap ,ve :vs <C-R>=expand('%:p:h') . '/'<CR>
nnoremap ,se :sp <C-R>=expand('%:p:h') . '/'<CR>

" <Bslash>e opens .vimrc in new window
nnoremap <Bslash>ev :<C-U>tabe $MYVIMRC<CR>

" <Bslash>s sources .vimrc
nnoremap <Bslash>sv :<C-U>source $MYVIMRC<CR>

" Clear search buffer with <C-L>
nnoremap <silent> <C-L> :<C-U>nohlsearch<Bar>diffupdate<CR><C-L>
vnoremap <silent> <C-L> :<C-U>nohlsearch<Bar>diffupdate<CR>gv<C-L>

" \c changes directory to current buffer's directory
nnoremap <silent> \c :<C-U>cd %:h<Bar>echo 'Changed directory to ' . getcwd()<CR>

" ,c changes local buffer directory to project directory (if the buffer is in
" a recognized Projectionist project) or the current buffer's directory
nnoremap <expr> ,c ":" . (exists(":Plcd")?"Plcd":"lcd %:h") . "\<Bar>echo 'Changed local directory to ' . getcwd()\<CR>"

" }}}

" Visual mode mappings {{{
vnoremap * y/\V<C-R>"<CR>
vnoremap # y?\V<C-R>"<CR>
" }}}

" Terminal mode mappings {{{
if exists(':tmap')
  tnoremap <silent> <C-W> <C-\><C-N><C-W>
  tnoremap <C-W><C-W> <C-W>
endif
" }}}

" Commands {{{

" Grep {{{

" Use ripgrep or ag as grepprg if available
if executable('rg')
  " Use rg over grep
  set grepprg=rg\ --vimgrep\ --smart-case
  set grepformat^=%f:%l:%c:%m
elseif executable('ag')
  " Use ag over grep
  set grepprg=ag\ --vimgrep\ --smart-case
  set grepformat^=%f:%l:%c:%m
endif

" Define a custom command to wrap :grep with :silent, :copen, and :redraw
command! -nargs=+ -bang Grep execute 'silent botright grep<bang> <args>' | copen | redraw!
nnoremap <Bslash><Bslash> :Grep!<space>
" }}}

" This comes from vimrc_example.vim. See :h :DiffOrig
command! DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
      \ | wincmd p | diffthis

" Edit ftplugin file for current filetype
function! s:EditFtplugin()
  if empty(&ft)
    echohl Error
    echom 'Error: This buffer has no filetype'
    return
  endif

  let ft = &ft
  execute 'e ' . $MYVIMRUNTIME . '/after/ftplugin/' . ft . '.vim'
endfunction
command! EditFtplugin call s:EditFtplugin()

" }}}

" Pushing built-in commands beyond their limits {{{
" https://gist.github.com/Konfekt/d8ce5626a48f4e56ecab31a89449f1f0
function! <sid>CCR()
  if getcmdtype() isnot# ':'
    return "\<CR>"
  endif
  let cmdline = getcmdline()
  if cmdline =~# '\v^\s*(ls|files|buffers)!?\s*(\s[+\-=auhx%#]+)?$'
    " like :ls but prompts for a buffer command
    return "\<CR>:b"
  elseif cmdline =~# '\v/(#|nu%[mber])$'
    " like :g//# but prompts for a command
    return "\<CR>:"
  elseif cmdline =~# '\v^\s*(dli%[st]|il%[ist])!?\s+\S'
    " like :dlist or :ilist but prompts for a count for :djump or :ijump
    return "\<CR>:" . cmdline[0] . "j  " . join(split(cmdline, " ")[1:]) . "\<C-B>\<S-Right>\<Right>"
  elseif cmdline =~# '\v^\s*(cli|lli)%[st]!?\s*(\s\d+(,\s*\d+)?)?$'
    " like :clist or :llist but prompts for an error/location number
    return "\<CR>:sil " . repeat(cmdline[0], 2) . "\<Space>"
  elseif cmdline =~# '\v^\s*ol%[dfiles]\s*$'
    " like :oldfiles but prompts for an old file to edit
    set nomore
    return "\<CR>:sil se more|e #<"
  elseif cmdline =~# '^\s*changes\s*$'
    " like :changes but prompts for a change to jump to
    set nomore
    return "\<CR>:sil se more|norm! g;\<S-Left>"
  elseif cmdline =~# '\v^\s*ju%[mps]'
    " like :jumps but prompts for a position to jump to
    set nomore
    return "\<CR>:sil se more|norm! \<C-o>\<S-Left>"
  elseif cmdline =~ '\v^\s*marks\s*(\s\w+)?$'
    " like :marks but prompts for a mark to jump to
    return "\<CR>:norm! `"
  elseif cmdline =~# '\v^\s*undol%[ist]'
    " like :undolist but prompts for a change to undo
    return "\<CR>:u "
  else
    return "\<c-]>\<CR>"
  endif
endfunction
cnoremap <expr> <CR> <sid>CCR()
" }}}

" Autocommands {{{
augroup vimrc
  autocmd!
  " Have Vim jump to the last position when reopening a file
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$")
        \ | exe "normal! g`\"" | endif

  " Set marks by filetype for quick navigation
  au BufLeave *.h normal! mH
  au BufLeave *.c,*.cc,*.cpp normal! mC
  au BufLeave *.py normal! mP

  " Start insert immediately when terminal opens
  if exists('##TermOpen')
    au TermOpen * setlocal nonumber | startinsert
  endif

  if has('nvim')
    au BufEnter term://* startinsert
  endif

  " Create syntax group for trailing whitespace in each new buffer
  au Syntax * syn match TrailingWhitespace /\s\+\%#\@<!$/ containedin=ALL
augroup END
" }}}

" Enable per-project configuration {{{
set exrc
set secure
" }}}
