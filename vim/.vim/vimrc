" Greg Anders (gpanders)'s vimrc <https://github.com/gpanders/dotfiles.git>

" Clear all vimrc autocmds at the beginning
augroup vimrc | autocmd! | augroup END

" Detect OS {{{
if !exists('g:os')
  if has('win64') || has('win32') || has('win16')
    let g:os = "Windows"
  else
    let g:os = substitute(system('uname'), '\n', '', '')
  endif
endif
" }}}

" Set $MYVIMRUNTIME
if g:os ==# 'Windows'
  let $MYVIMRUNTIME = $HOME . '/vimfiles'
else
  let $MYVIMRUNTIME = $HOME . '/.vim'
endif

" Use vim-pathogen if native packages are not supported {{{
if !has('packages')
  " Use vim-pathogen to emulate native packaging behavior
  if empty(glob($MYVIMRUNTIME . '/autoload/pathogen.vim'))
    silent execute '!curl -LSso ' . $MYVIMRUNTIME . '/autoload/pathogen.vim https://tpo.pe/pathogen.vim'
  endif
  silent! execute pathogen#infect('pack/{}/start/{}', 'pack/{}/opt/{}')
endif
" }}}

if has('autocmd')
  filetype plugin indent on
endif

if has('syntax') && !exists('g:syntax_on')
  syntax enable
endif

" Set color scheme {{{
if has('termguicolors')
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors
else
  let g:onedark_termcolors = 16
endif

" Colorscheme post-setup {{{
" Modify color schemes in this function. This function will be called after the colorscheme is set
" in the ColorScheme autocmd

" Set User1-9 highlight groups for statusline
" These are used by adding %N* to the statusline, where {N} is 1-9
function! s:colors()
  if !exists('g:colors_name')
    finish
  endif
  if g:colors_name ==# 'flattened'
    if &background ==# 'light'
      hi User1 ctermfg=15 ctermbg=11 guifg=#fdf6e3 guibg=#657b83
      hi User2 ctermfg=15 ctermbg=14 guifg=#fdf6e3 guibg=#93a1a1
      hi User3 ctermfg=11 ctermbg=7 guifg=#657b83 guibg=#eee8d5
      hi User4 ctermfg=15 ctermbg=14 guifg=#fdf6e3 guibg=#93a1a1
      hi User5 ctermfg=15 ctermbg=11 guifg=#fdf6e3 guibg=#657b83
      hi link StatuslineModeNormal Normal
      hi StatuslineModeInsert ctermfg=4 guifg=#61afef
      hi StatuslineModeReplace ctermfg=1 guifg=#e06c75
      hi StatuslineModeVisual ctermfg=5 guifg=#c678dd
    else
      hi User1 ctermfg=8 ctermbg=12 guifg=#002b36 guibg=#839496
      hi User2 ctermfg=8 ctermbg=10 guifg=#002b36 guibg=#586e75
      hi User3 ctermfg=12 ctermbg=0 guifg=#839496 guibg=#073642
      hi User4 ctermfg=8 ctermbg=10 guifg=#002b36 guibg=#586e75
      hi User5 ctermfg=8 ctermbg=12 guifg=#002b36 guibg=#839496
      hi link StatuslineModeNormal Normal
      hi StatuslineModeInsert ctermfg=4 guifg=#61afef
      hi StatuslineModeReplace ctermfg=1 guifg=#e06c75
      hi StatuslineModeVisual ctermfg=5 guifg=#c678dd
    endif
  elseif g:colors_name ==# 'base16-eighties'
    hi User1 term=bold,reverse ctermfg=12 ctermbg=11 guifg=#a09f93 guibg=#515151
    hi User2 term=bold,reverse ctermfg=8 ctermbg=0 guifg=#747369 guibg=#2d2d2d
    hi User3 term=bold,reverse ctermfg=8 ctermbg=0 guifg=#747369 guibg=#2d2d2d
    hi User4 term=bold,reverse ctermfg=12 ctermbg=11 guifg=#a09f93 guibg=#515151
    hi User5 term=bold,reverse ctermfg=12 ctermbg=11 guifg=#a09f93 guibg=#515151

    hi link StatuslineModeNormal Normal
    hi StatuslineModeInsert ctermfg=4 guifg=#6699cc
    hi StatuslineModeReplace ctermfg=1 guifg=#f2777a
    hi StatuslineModeVisual ctermfg=5 guifg=#cc99cc

    " These groups look really bad by default, so make them better
    hi SpellBad term=underline cterm=underline ctermfg=1 gui=underline guifg=#f2777a
    hi WildMenu ctermbg=11 ctermfg=15 guibg=#515151 guifg=#f2f0ec
    hi clear Underlined
    hi Underlined term=underline cterm=underline gui=underline
  elseif g:colors_name ==# 'base16-onedark'
    hi User1 cterm=reverse gui=reverse
    hi User2 ctermbg=10 guibg=#353b45
    hi User3 ctermfg=7 guifg=#abb2bf
    hi link User4 User2
    hi User5 cterm=reverse gui=reverse

    hi link StatuslineModeNormal Normal
    hi StatuslineModeInsert ctermfg=4 guifg=#61afef
    hi StatuslineModeReplace ctermfg=1 guifg=#e06c75
    hi StatuslineModeVisual ctermfg=5 guifg=#c678dd
  elseif g:colors_name ==# 'apprentice'
    hi User1 term=bold,reverse ctermfg=235 ctermbg=101 guifg=#262626 guibg=#87875f
    hi User2 ctermfg=242 ctermbg=235 guifg=#6c6c6c guibg=#262626
    hi User3 ctermfg=242 ctermbg=235 guifg=#6c6c6c guibg=#262626
    hi User4 term=bold,reverse ctermfg=235 ctermbg=101 guifg=#262626 guibg=#87875f
    hi User5 term=bold,reverse ctermfg=235 ctermbg=101 guifg=#262626 guibg=#87875f

    hi link StatuslineModeNormal Normal
    hi StatuslineModeInsert ctermfg=4 guifg=#5f87af
    hi StatuslineModeReplace ctermfg=1 guifg=#af5f5f
    hi StatuslineModeVisual ctermfg=5 guifg=#5f5f87
  endif
endfunction

autocmd vimrc ColorScheme * call s:colors()
" }}}
"
" Try to make comments italic
autocmd vimrc ColorScheme * highlight Comment gui=italic cterm=italic

" Load colorscheme
let base16colorspace = 256
silent! colorscheme base16-eighties

" If no other colorscheme, use vim default
if !exists('g:colors_name')
  set bg=dark
endif

" Highlight trailing whitespace
highlight TrailingWhitespace ctermbg=204 guibg=#E06C75

" }}}

" GUI settings {{{
if has('gui_running')
  if g:os ==# 'Windows'
    set guifont=Fira_Mono:h10:cANSI:qDRAFT
  elseif g:os ==# 'Darwin'
    set guifont=FiraMono-Regular:h11
  endif
  set guioptions=teMg!
  set lines=60
  set columns=180
endif
" }}}

" Set curor shape based on mode
if !has('nvim')
  " Vertical bar in insert mode
  let &t_SI = "\e[6 q"
  " Underline in replace mode
  let &t_SR = "\e[4 q"
  " Block in normal mode
  let &t_EI = "\e[2 q"
endif

" Use UTF-8 if we can and env LANG didn't tell us not to
if has('multi_byte') && !exists('$LANG') && &encoding ==# 'latin1'
  set encoding=utf-8
endif

" Sudo save
cnoreabbrev w!! w !sudo tee > /dev/null %

" Settings {{{
" Press K to open help docs for option under the cursor
set autoindent
set autoread
set backup
set confirm
set cursorline
set display+=lastline
set expandtab
set foldmarker=\ {{{,\ }}}
set hidden
set hlsearch
set ignorecase
set include=
set incsearch
set nolangremap
set lazyredraw
set linebreak
set magic
set matchpairs+=<:>
set matchtime=2
set modeline
set nrformats-=octal
set number
set pumheight=10
set scrolloff=2
set shiftwidth=4
set showmatch
set noshowmode
set sidescrolloff=5
set smartcase
set smarttab
set softtabstop=4
set splitbelow
set splitright
set nostartofline
set noswapfile
set tagcase=smart
set virtualedit+=block

if has('nvim')
  set inccommand=nosplit
endif

" Enable undofile if possible
if has('persistent_undo')
  set undofile
endif

" Color the whole area outside of 'textwidth'
let &colorcolumn = '+' . join(range(1, 256), ',+')

" Indent wrapped lines
silent! set breakindent

" Add more completion options
set completeopt=menu,preview

if !has('nvim') && &ttimeoutlen == -1
  set ttimeout
  set ttimeoutlen=100
endif

" Allow backspacing over all whitespace
set backspace=indent,eol,start

" Specify whitespace chars
set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+

" Delete comment characters when joining commented lines
set formatoptions+=j

if has('path_extra')
  setglobal tags-=./tags tags-=./tags; tags^=./tags;
endif

" Increase Vim's command history
set history=1000

" Set max number of tab pages
set tabpagemax=50

" Keep and store UPPERCASE global variables
if !empty(&viminfo)
  set viminfo^=!
endif

" Don't save options in session files
set sessionoptions-=options

set path-=/usr/include     " Let C/C++ filetypes set this
set path+=**               " Search current directory's whole tree

set ruler
set wildmenu
set wildcharm=<C-Z>
set wildmode=longest:full,full
set wildignorecase
set wildignore+=*/.git/**/*,*/.hg/**/*,*/.svn/**/*
set wildignore+=tags
" }}}

" Statusline {{{
" Set the statusline

let s:statusline_separator = ' / '

function! StatuslineLineEnding()
  if &ff ==# 'unix'
    return 'LF' . s:statusline_separator
  elseif &ff ==# 'dos'
    return 'CRLF' . s:statusline_separator
  elseif &ff ==# 'mac'
    return 'CR' . s:statusline_separator
  endif
  return ''
endfunction

function! StatuslineFileType()
  if &ft ==# ''
    return 'none'
  else
    return &ft
  endif
endfunction

function! StatuslineGitBranch()
  if exists('*FugitiveHead')
    let branch = FugitiveHead()
    if branch != ''
      return branch . s:statusline_separator
    endif
  endif
  return ''
endfunction

function! StatuslineMode()
  let m = mode()
  if m ==# 'n'
    highlight! link StatuslineMode StatuslineModeNormal
    return 'N'
  elseif m ==# 'i'
    highlight! link StatuslineMode StatuslineModeInsert
    return 'I'
  elseif m ==# 'R'
    highlight! link StatuslineMode StatuslineModeReplace
    return 'R'
  elseif m ==? 'v' || m ==# ''
    highlight! link StatuslineMode StatuslineModeVisual
    return 'V'
  else
    highlight! link StatuslineMode StatuslineModeNormal
    return toupper(m)
  endif
endfunction

" Initialize StatuslineMode highlight group
highlight! link StatuslineMode StatuslineModeNormal

function! StatuslineFlags()
  let str = ''
  if &mod
    let str .= '+ '
  endif
  if &ro
    let str .= '[RO] '
  endif
  return str
endfunction

set laststatus=2
set statusline=                             | " Reset the statusline
set statusline+=%#StatuslineMode#           |
set statusline+=\ %{StatuslineMode()}\      | " Mode indicator
set statusline+=%*                          |
set statusline+=%1*\ %<%f\                  | " Filename
set statusline+=%{StatuslineFlags()}        | " Help/modified/RO markers
set statusline+=%2*                         | " Filetype
set statusline+=%=                          | " Break point for right justify

set statusline+=%3*                         | " Reset color
set statusline+=%{StatuslineGitBranch()}    | " Git branch (with icon)
set statusline+=%{StatuslineLineEnding()}   | " Line ending
set statusline+=%{StatuslineFileType()}\    | " Filetype
set statusline+=%4*\                      | " Color boundary
set statusline+=%(%l:%c%V%)                 | " Line and column number
set statusline+=\ %5*                       | " Color boundary 5
set statusline+=%P\                         | " Percent through file

" }}}

" Keep temporary files in a single location
if g:os ==# 'Windows'
  let cachedir = $HOME . '/vimfiles/cache'
else
  if exists('$XDG_CACHE_HOME')
    let cachedir = $XDG_CACHE_HOME . '/vim'
  else
    let cachedir = $HOME . '/.cache/vim'
  endif
endif

let &g:backupdir = cachedir . '/backup//' . ',' . &g:backupdir
let &g:undodir = cachedir . '/undo//' . ',' . &g:undodir
let &g:directory = cachedir . '/swap//' . ',' . &g:directory

" Set dictionary if it exists
if g:os !=# 'Windows' && filereadable('/usr/share/dict/words')
  set dictionary+=/usr/share/dict/words
endif

" Insert mode mappings {{{

" jk in Insert mode escapes to Normal mode
inoremap jk <Esc>l

" Set a new 'undo point' before undoing entire line
inoremap <C-U> <C-G>u<C-U>

" Auto close braces in insert mode
inoremap {<CR> {<CR>}<Esc>ko

" Insert current date with <C-\>d
inoremap <silent> <C-\>d <C-R>=strftime('%Y-%m-%d')<CR>

" }}}

" Normal mode mappings {{{

" Save by pressing <leader>w
nnoremap <silent> ,w :w<CR>

" Navigate through wrapped lines individually
nnoremap <silent> j gj
nnoremap <silent> k gk

" Map Q to gq
noremap Q gq

" Buffer shortcuts
nnoremap <silent> ,1 :b1<CR>
nnoremap <silent> ,2 :b2<CR>
nnoremap <silent> ,3 :b3<CR>
nnoremap <silent> ,4 :b4<CR>
nnoremap <silent> ,5 :b5<CR>
nnoremap <silent> ,6 :b6<CR>
nnoremap <silent> ,7 :b7<CR>
nnoremap <silent> ,8 :b8<CR>
nnoremap <silent> ,9 :b9<CR>
nnoremap <silent> ,0 :b10<CR>

" List buffers and put :b on the command line
noremap ,b :buffers<CR>:b<Space>

" Remap & to preserve substitution flags
nnoremap <silent> & :&&<CR>

" <Space><Tab> goes back to previous buffer
nnoremap <silent> <Space><Tab> <C-^>

" Map ,, to ,
nnoremap ,, ,

" ,f prefixes find files in path
nnoremap ,f :find *
nnoremap ,vf :vert sf *
nnoremap ,sf :sf *

" Search for a tag by regex
nnoremap ,t :tjump /
nnoremap ,p :ptjump /

" Find files in current buffer's directory
nnoremap ,e :e <C-R>=expand('%:p:h') . '/'<CR>
nnoremap ,ve :vs <C-R>=expand('%:p:h') . '/'<CR>
nnoremap ,se :sp <C-R>=expand('%:p:h') . '/'<CR>

" <Bslash>e opens .vimrc in new window
nnoremap <Bslash>ev :<C-U>tabe $MYVIMRC<CR>

" <Bslash>s sources .vimrc
nnoremap <Bslash>sv :<C-U>source $MYVIMRC<CR>

" Clear search buffer with <C-L>
nnoremap <silent> <C-L> :<C-U>nohlsearch<Bar>diffupdate<CR><C-L>
vnoremap <silent> <C-L> :<C-U>nohlsearch<Bar>diffupdate<CR>gv<C-L>

" \c changes directory to current buffer's directory
nnoremap <silent> \c :cd %:p:h<Bar>echo 'Changed directory to ' . getcwd()<CR>

" ,c changes local working directory to buffer's directory
nnoremap <silent> ,c :lcd %:p:h<Bar>echo 'Changed directory to ' . getcwd()<CR>

" Format whole buffer with formatprg without changing cursor position
nnoremap <Space>gq mzHmygggqG`yzt`z

" Show tag stack
nnoremap <Space>t :tags<CR>

" Navigate through tag stack
nnoremap <expr> >t ":\<C-U>" . v:count1 . "tag\<CR>"

" This is the same as CTRL-T, but it's nice to have symmetry
nnoremap <expr> <t ":\<C-U>" . v:count1 . "pop\<CR>"

nnoremap <expr> <q ":\<C-U>colder " . v:count1 . "\<CR>"
nnoremap <expr> >q ":\<C-U>cnewer " . v:count1 . "\<CR>"
nnoremap <expr> <l ":\<C-U>lolder " . v:count1 . "\<CR>"
nnoremap <expr> >l ":\<C-U>lnewer " . v:count1 . "\<CR>"

" Show registers
nnoremap <Space>r :registers<CR>

" Show marks
nnoremap <Space>m :marks<CR>:norm! `

" Show only user placed marks (A-Z and a-z)
let s:alphabet = join(map(
      \ range(char2nr('A'), char2nr('Z')) + range(char2nr('a'), char2nr('z')),
      \ 'nr2char(v:val)'), '')
execute 'nnoremap <Space>M :marks ' . s:alphabet . '<CR>'

" }}}

" Visual mode mappings {{{
vnoremap * y/\V<C-R>"<CR>
vnoremap # y?\V<C-R>"<CR>
" }}}

" Terminal mode mappings {{{
if exists(':tmap') == 2
  tnoremap <silent> <C-W> <C-\><C-N><C-W>
  tnoremap <C-W><C-W> <C-W>
endif
" }}}

" Commands {{{

" Grep {{{

" Use ripgrep or ag as grepprg if available
if executable('rg')
  " Use rg over grep
  set grepprg=rg\ --vimgrep\ --smart-case
  set grepformat^=%f:%l:%c:%m
elseif executable('ag')
  " Use ag over grep
  set grepprg=ag\ --vimgrep\ --smart-case
  set grepformat^=%f:%l:%c:%m
endif

" Define a custom command to wrap :grep with :silent, :copen, and :redraw
command! -nargs=+ -bang Grep execute 'silent botright grep<bang> ' . shellescape(<q-args>, 1) | cwindow | redraw!
nnoremap <Bslash><Bslash> :Grep!<space>
" }}}

" This comes from vimrc_example.vim. See :h :DiffOrig
command! DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
      \ | wincmd p | diffthis

" Edit ftplugin file for current filetype
command! EditFtplugin
      \ if empty(&ft) |
      \   echohl Error | echo 'Error: This buffer has no filetype' |
      \ else |
      \   execute 'e ' . $MYVIMRUNTIME . '/after/ftplugin/' . &ft . '.vim' |
      \ endif

" }}}

" Pushing built-in commands beyond their limits {{{
" https://gist.github.com/Konfekt/d8ce5626a48f4e56ecab31a89449f1f0
function! <sid>CCR()
  if getcmdtype() isnot# ':'
    return "\<CR>"
  endif
  let cmdline = getcmdline()
  if cmdline =~# '\v^\s*(ls|files|buffers)!?\s*(\s[+\-=auhx%#]+)?$'
    " like :ls but prompts for a buffer command
    return "\<CR>:b"
  elseif cmdline =~# '\v/(#|nu%[mber])$'
    " like :g//# but prompts for a command
    return "\<CR>:"
  elseif cmdline =~# '\v^\s*(dli%[st]|il%[ist])!?\s+\S'
    " like :dlist or :ilist but prompts for a count for :djump or :ijump
    return "\<CR>:" . cmdline[0] . "j  " . join(split(cmdline, " ")[1:]) . "\<C-B>\<S-Right>\<Right>"
  elseif cmdline =~# '\v^\s*(cli|lli)%[st]!?\s*(\s\d+(,\s*\d+)?)?$'
    " like :clist or :llist but prompts for an error/location number
    return "\<CR>:sil " . repeat(cmdline[0], 2) . "\<Space>"
  elseif cmdline =~# '\v^\s*ol%[dfiles]\s*$'
    " like :oldfiles but prompts for an old file to edit
    set nomore
    return "\<CR>:sil se more|e #<"
  elseif cmdline =~# '^\s*changes\s*$'
    " like :changes but prompts for a change to jump to
    set nomore
    return "\<CR>:sil se more|norm! g;\<S-Left>"
  elseif cmdline =~# '\v^\s*ju%[mps]'
    " like :jumps but prompts for a position to jump to
    set nomore
    return "\<CR>:sil se more|norm! \<C-o>\<S-Left>"
  elseif cmdline =~ '\v^\s*marks\s*(\s\w+)?$'
    " like :marks but prompts for a mark to jump to
    return "\<CR>:norm! `"
  elseif cmdline =~# '\v^\s*undol%[ist]'
    " like :undolist but prompts for a change to undo
    return "\<CR>:u "
  else
    return "\<c-]>\<CR>"
  endif
endfunction
cnoremap <expr> <CR> <sid>CCR()
" }}}

" Autocommands {{{
augroup vimrc
" Have Vim jump to the last position when reopening a file
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$")
      \ | exe "normal! g`\"" | endif

" Set marks by filetype for quick navigation
autocmd BufLeave *.h normal! mH
autocmd BufLeave *.c,*.cc,*.cpp normal! mC
autocmd BufLeave *.py normal! mP

" Start insert immediately when terminal opens
if exists('##TermOpen')
  autocmd TermOpen * setlocal nonumber | startinsert
endif

if has('nvim')
  autocmd BufEnter term://* startinsert
endif

" Create syntax group for trailing whitespace in each new buffer
autocmd Syntax * syn match TrailingWhitespace /\s\+\%#\@<!$/ containedin=ALL

augroup END
" }}}

" Enable per-project configuration {{{
set exrc
set secure
" }}}
