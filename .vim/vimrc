if !has('nvim')
  filetype plugin indent on
  set autoindent
  set autoread
  set backspace=indent,eol,start
  silent! set belloff=all
  set complete-=i
  set display=lastline
  set nofsync
  set formatoptions+=j
  set history=10000
  set hlsearch
  set incsearch
  set langnoremap
  silent! set nolangremap
  set laststatus=2
  set nrformats-=octal
  set ruler
  set sessionoptions-=options
  silent! set shortmess+=F
  set showcmd
  set sidescroll=1
  set smarttab
  set tabpagemax=50
  set tags=./tags;,tags
  set ttimeout
  set ttimeoutlen=50
  set ttyfast
  set viminfo^=!
  set wildmenu

  set encoding=utf-8
  scriptencoding utf-8

  " Set cursor shape based on mode (:h termcap-cursor-shape)
  " Vertical bar in insert mode
  let &t_SI = "\e[6 q"
  " Underline in replace mode
  let &t_SR = "\e[4 q"
  " Block in normal mode
  let &t_EI = "\e[2 q"

  let s:datadir = vim#datadir()
  let &backupdir = s:datadir . '/backup//,' . &backupdir
  let &directory = s:datadir . '/swap//,' . &directory
  let &undodir = s:datadir . '/undo//,' . &undodir
  unlet s:datadir

  call vim#mkdirs()
endif

augroup vimrc | execute 'autocmd!' | augroup END

if !exists('g:syntax_on')
  syntax enable
endif

autocmd vimrc ColorScheme * highlight Comment gui=italic cterm=italic

silent! colorscheme base16-eighties

highlight link TrailingWhitespace Error

set backup
set backupdir-=.
set breakindent
set confirm
set cursorline
set expandtab
set foldlevelstart=99
set hidden
set ignorecase
silent! set inccommand=nosplit
set lazyredraw
set linebreak
set listchars=tab:>\ ,trail:-,extends:>,precedes:<,nbsp:+
set matchpairs+=<:>
set pumheight=10
set scrolloff=2
set shell=/bin/sh
set shiftwidth=4
set showmatch
set sidescrolloff=5
set smartcase
set noswapfile
set tagcase=match
set undofile
set virtualedit+=block
set wildcharm=<Tab>
set wildignore+=*.pyc,__pycache__,.DS_Store,*~,#*#
set wildignorecase
set wildmode=longest:full,full

let &colorcolumn = '+' . join(range(1, 256), ',+')

setglobal path=.,,
setglobal include=
setglobal includeexpr=
setglobal define=
setglobal isfname+=@-@

set grepformat^=%f:%l:%c:%m
if executable('rg')
  set grepprg=rg\ --vimgrep\ --smart-case
else
  set grepprg=grep\ --line-number\ --recursive\ -I\ $*\ /dev/null
endif

" Enable indent-heuristic to make vimdiff more closely match git diff
set diffopt+=indent-heuristic

" Set undo points when deleting
inoremap <C-U> <C-G>u<C-U>
inoremap <C-W> <C-G>u<C-W>

" Auto close braces in insert mode
inoremap {<CR> {<CR>}<Esc>O

" Copy line above/below (similar to <C-Y>/<C-E> but works on the whole line)
inoremap <expr> <C-G><C-Y> repeat('<C-Y>', len(getline(line('.')-1))-col('.')+1)
inoremap <expr> <C-G><C-E> repeat('<C-E>', len(getline(line('.')-1))-col('.')+1)

" Navigate through popup menu with Tab and S-Tab and use Enter to make a
" selection. If popup menu is not visible, Enter should set an undo point
" before inserting a newline
inoremap <expr> <Tab> pumvisible() ? "\<C-N>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<C-P>" : "\<S-Tab>"
inoremap <expr> <CR> pumvisible() ? "\<C-Y>" : "\<C-]><C-G>u\<CR>"

inoremap <C-R>! <C-O>:r !

" Make * and # work in visual mode
xnoremap * y/\V<C-R>"<CR>
xnoremap # y?\V<C-R>"<CR>

nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap Q <Nop>
nnoremap gQ <Nop>
nnoremap <Space>w :w<CR>
nnoremap <Space>b :ls<CR>:b<Space>
nnoremap <C-W><Space>b :ls<CR>:sb<Space>
nnoremap <Space>] :tjump /
nnoremap <C-W><Space>] :stjump /
nnoremap <Space>} :ptjump /
nnoremap <Space>e :e %:p:h/<Tab>
nnoremap <C-W><Space>e :sp %:p:h/<Tab>
nnoremap <silent> <C-L> :<C-U>nohlsearch<Bar>diffupdate<Bar>syn sync minlines=50<CR><C-L>
vnoremap <silent> <C-L> :<C-U>nohlsearch<Bar>diffupdate<Bar>syn sync minlines=50<CR>gv<C-L>

" Format whole buffer with formatprg without changing cursor position
" See :h restore-position
nnoremap gq<CR> mzHmygggqG`yzt`z

" Allow [[ and friends to work when opening brace is not in the first column
noremap <silent> [[ ?{<CR>w99[{:let @/ = ''<CR>
noremap <silent> ][ /}<CR>b99]}:let @/ = ''<CR>
noremap <silent> ]] j0?{<CR>w99[{%/{<CR>:let @/ = ''<CR>
noremap <silent> [] k$/}<CR>b99]}%?}<CR>:let @/ = ''<CR>

" Unimpaired style mappings
nnoremap <expr> [a ":\<C-U>" . v:count1 . "prev\<CR>"
nnoremap <expr> ]a ":\<C-U>" . v:count1 . "next\<CR>"
nnoremap <expr> [b ":\<C-U>" . v:count1 . "bprev\<CR>"
nnoremap <expr> ]b ":\<C-U>" . v:count1 . "bnext\<CR>"
nnoremap <expr> [l ":\<C-U>" . v:count1 . "lprev\<CR>"
nnoremap <expr> ]l ":\<C-U>" . v:count1 . "lnext\<CR>"
nnoremap <expr> [<C-L> ":\<C-U>" . v:count1 . "lolder\<CR>"
nnoremap <expr> ]<C-L> ":\<C-U>" . v:count1 . "lnewer\<CR>"
nnoremap <expr> [q ":\<C-U>" . v:count1 . "cprev\<CR>"
nnoremap <expr> ]q ":\<C-U>" . v:count1 . "cnext\<CR>"
nnoremap <expr> [<C-Q> ":\<C-U>" . v:count1 . "colder\<CR>"
nnoremap <expr> ]<C-Q> ":\<C-U>" . v:count1 . "cnewer\<CR>"
nnoremap <expr> [t ":\<C-U>" . v:count1 . "tprev\<CR>"
nnoremap <expr> ]t ":\<C-U>" . v:count1 . "tnext\<CR>"
nnoremap [A :<C-U>first<CR>
nnoremap ]A :<C-U>last<CR>
nnoremap [B :<C-U>bfirst<CR>
nnoremap ]B :<C-U>blast<CR>
nnoremap [L :<C-U>lfirst<CR>
nnoremap ]L :<C-U>llast<CR>
nnoremap [Q :<C-U>cfirst<CR>
nnoremap ]Q :<C-U>clast<CR>
nnoremap [T :<C-U>tfirst<CR>
nnoremap ]T :<C-U>tlast<CR>
nnoremap <expr> [e ":\<C-U>.move --" . v:count1 . "\<CR>"
nnoremap <expr> ]e ":\<C-U>.move +" . v:count1 . "\<CR>"
xnoremap <expr> [e ":move --" . v:count1 . "\<CR>gv"
xnoremap <expr> ]e ":move +" . (v:count1 + line("'>") - line("'<")) . "\<CR>gv"
nnoremap [<Space> :<C-U>put! =repeat(nr2char(10), v:count1)<CR><CR>:']+1<CR>
nnoremap ]<Space> :<C-U>put =repeat(nr2char(10), v:count1)<CR><CR>:'[-1<CR>
nnoremap <expr> yon ':setlocal ' . (&number ? 'no' : '') . "number\<CR>"
nnoremap <expr> yor ':setlocal ' . (&relativenumber ? 'no' : '') . "relativenumber\<CR>"
nnoremap <expr> yol ':setlocal ' . (&list ? 'no' : '') . "list\<CR>"
nnoremap <expr> yoc ':setlocal ' . (&cursorline ? 'no' : '') . "cursorline\<CR>"
nnoremap <expr> yo<Bar> ':setlocal ' . (&cursorcolumn ? 'no' : '') . "cursorcolumn\<CR>"
nnoremap <expr> yod ':' . (&diff ? 'diffoff' : 'diffthis') . "\<CR>"
nnoremap <expr> yos ':setlocal ' . (&spell ? 'no' : '') . "spell\<CR>"

nnoremap m<CR> :make<CR>
nnoremap m<Space> :make<Space>
nnoremap m? :set makeprg?<CR>

function! Sort(type, ...) abort
    '[,']sort
    call setpos('.', getpos("''"))
endfunction
nnoremap <silent> gs m':set operatorfunc=Sort<CR>g@
xnoremap <silent> gs :sort<CR>

nnoremap g/ :<C-U>g//#<Left><Left>

cnoremap <expr> <C-P> wildmenumode() ? "\<C-P>" : "\<Up>"
cnoremap <expr> <C-N> wildmenumode() ? "\<C-N>" : "\<Down>"

if &wildoptions =~# 'pum'
  cnoremap <expr> <C-J> pumvisible() ? "\<Down>\<Tab>" : "\<C-J>"
  cnoremap <expr> <C-K> pumvisible() ? "\<Up>\<Tab>" : "\<C-K>"
else
  cnoremap <expr> <C-J> wildmenumode() ? "\<Down>\<Tab>" : "\<C-J>"
  cnoremap <expr> <C-K> wildmenumode() ? "\<Up>\<Tab>" : "\<C-K>"
endif

augroup vimrc

autocmd BufWinEnter * if &previewwindow | nnoremap <buffer> q <C-W>q | endif

" See :h ft-syntax-omni
autocmd FileType * if &omnifunc == '' | setlocal omnifunc=syntaxcomplete#Complete | endif

if argc() == 0 && filereadable('Session.vim')
  if v:vim_did_enter
    source Session.vim
  else
    autocmd VimEnter * nested source Session.vim
  endif
endif

augroup END
